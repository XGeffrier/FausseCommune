<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fausse Commune</title>

    <!-- Favicon -->
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.svg') }}">

    <!-- Biblioth√®ques externes -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        /* ===== RESET ET BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #a8dadc 0%, #457b9d 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ===== CONTENEUR PRINCIPAL ===== */
        .container {
            max-width: 1400px;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Hauteur dynamique : prend l'espace disponible sans d√©border */
            max-height: calc(100vh - 40px);
        }

        /* ===== HEADER (TITRE + BOUTON AIDE) ===== */
        .header {
            background: linear-gradient(135deg, #a8dadc 0%, #457b9d 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0; /* Ne pas r√©tr√©cir le header */
        }

        .title {
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        /* Container pour le texte + bouton d'aide */
        .help-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Texte "Comment jouer" */
        .help-text {
            font-size: 16px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
        }


        /* Bouton d'aide (?) */
        .help-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .help-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* ===== WRAPPER DU JEU (CARTE + INDICES) ===== */
        .game-wrapper {
            display: flex;
            flex-direction: row;
            flex: 1; /* Prend tout l'espace restant */
            overflow: hidden; /* √âvite les d√©bordements */
        }

        /* ===== CONTENEUR DE LA CARTE ===== */
        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px; /* Hauteur minimum */
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* ===== CONTENEUR DES INDICES ===== */
        .hints-container {
            width: 350px;
            background: #f8f9fa;
            border-left: 3px solid #457b9d;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* √âvite les d√©bordements */
        }

        /* Section des indices */
        .hints-section {
            flex: 1; /* Prend l'espace disponible */
            padding: 30px;
            overflow-y: auto; /* Scroll si trop d'indices */
            display: flex;
            flex-direction: column;
        }

        .hints-header {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .hints-list {
            list-style: none;
            flex: 1;
        }

        .hint-item {
            background: white;
            padding: 10px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #457b9d;
            font-size: 16px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 20px;
            color: #457b9d;
        }

        /* ===== SECTION SCORE ===== */
        .score-section {
            padding: 20px 30px;
            background: white;
            flex-shrink: 0; /* Ne pas r√©tr√©cir */
            border-top: 2px solid #e0e0e0;
        }

        /* Par d√©faut, affiche desktop et cache mobile */
        .score-mobile {
            display: none;
        }

        .score-desktop {
            display: block;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }

        .score-label {
            font-size: 16px;
            color: #666;
            font-weight: 500;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: #457b9d;
        }

        .best-score-value {
            color: #f39c12; /* Couleur dor√©e pour le meilleur score */
        }

        /* ===== OVERLAY DE VICTOIRE ===== */
        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .victory-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .victory-message {
            background: white;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            font-size: 36px;
            font-weight: bold;
            color: #457b9d;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        /* ===== MODALES (GAME OVER + AIDE) ===== */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-title {
            font-size: 28px;
            font-weight: bold;
            color: #d9534f;
            margin-bottom: 20px;
        }

        .modal-title.help-title {
            color: #457b9d;
        }

        .modal-text {
            font-size: 16px;
            line-height: 1.6;
            color: #333;
            margin-bottom: 20px;
            text-align: left;
        }

        .modal-text p {
            margin-bottom: 16px;
        }

        .modal-text p:last-child {
            margin-bottom: 0;
        }

        .modal-button {
            background: #457b9d;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 20px;
        }

        .modal-button:hover {
            background: #1d3557;
        }

        .modal-button.secondary {
            background: #6c757d;
            margin-left: 10px;
        }

        .modal-button.secondary:hover {
            background: #5a6268;
        }

        /* ===== RESPONSIVE MOBILE ===== */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                max-height: 100vh;
                border-radius: 0;
            }

            .header {
                padding: 15px 20px;
            }

            .title {
                font-size: 24px;
            }

            /* Cache le texte "Comment jouer" sur mobile */
            .help-text {
                display: none;
            }

            .help-button {
                width: 35px;
                height: 35px;
                font-size: 20px;
            }

            /* Empilement vertical sur mobile */
            .game-wrapper {
                flex-direction: column;
            }

            /* Affiche score mobile, cache score desktop */
            .score-mobile {
                display: block;
                border-bottom: 2px solid #e0e0e0;
                border-top: none;
            }

            .score-desktop {
                display: none;
            }

            .hints-container {
                width: 100%;
                border-left: none;
                border-top: 3px solid #457b9d;
                max-height: 40vh;
            }

            .hints-section {
                padding: 20px;
            }

            .map-container {
                min-height: 300px;
                height: 40vh; /* Hauteur fixe sur mobile */
                flex: 0 0 auto; /* Ne pas √©tirer */
            }

            .score-section {
                padding: 15px 20px;
            }

            .mobile-score-line {
                display: flex;
                justify-content: center;
                align-items: center;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <!-- ===== HEADER AVEC TITRE ET BOUTON AIDE ===== -->
    <div class="header">
<div class="title"><img src="/static/favicon.svg" alt="Logo"
style="height: 1em; vertical-align: -0.2em; margin-right: 0.3em;">Fausse Commune
        </div>
        <div class="help-wrapper">
            <span class="help-text">R√®gles du jeu</span>
            <button class="help-button" onclick="showHelp()" aria-label="Aide">?</button>
        </div>
    </div>

    <!-- ===== JEU (CARTE + INDICES) ===== -->
    <div class="game-wrapper">
        <!-- Section score MOBILE uniquement (au-dessus de la carte) -->
        <div class="score-section score-mobile">
            <div class="mobile-score-line">
                <span class="score-label" id="mobile-score-display"></span>
            </div>
        </div>

        <!-- CARTE -->
        <div class="map-container">
            <div id="map"></div>
        </div>

        <!-- INDICES ET SCORE -->
        <div class="hints-container">
            <!-- Section indices -->
            <div class="hints-section">
                <ul class="hints-list" id="hints-list">
                    <li class="loading">Chargement...</li>
                </ul>
            </div>

            <!-- Section score DESKTOP uniquement (sous les indices) -->
            <div class="score-section score-desktop">
                <div class="score-item">
                    <span class="score-label">Vies :</span>
                    <span class="score-value" id="lives-display-desktop">‚ù§Ô∏è‚ù§Ô∏è</span>
                </div>
                <div class="score-item">
                    <span class="score-label">Score actuel :</span>
                    <span class="score-value" id="current-score-desktop">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">Meilleur score :</span>
                    <span class="score-value best-score-value" id="best-score-desktop">0</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ===== OVERLAY DE VICTOIRE ===== -->
<div class="victory-overlay" id="victory-overlay">
    <div class="victory-message" id="victory-message">
        Round 1 gagn√© ! üéâ
    </div>
</div>

<!-- ===== MODALE VIE PERDUE ===== -->
<div class="modal" id="life-lost-modal">
    <div class="modal-content">
        <div class="modal-title">üíî Vie perdue !</div>
        <p class="modal-text">Il vous reste <strong><span id="remaining-lives">2</span></strong> vie(s).</p>
        <button class="modal-button" onclick="continueAfterLifeLost()">Continuer</button>
    </div>
</div>

<!-- ===== MODALE GAME OVER ===== -->
<div class="modal" id="game-over-modal">
    <div class="modal-content">
        <div class="modal-title">üò¢ Perdu !</div>
        <p class="modal-text">Nombre de rounds remport√©s : <strong><span id="final-round">0</span></strong></p>
        <div style="margin: 20px 0; font-size: 24px;" id="history-display"></div>
        <button class="modal-button" onclick="shareResult()" style="display: flex; align-items: center; justify-content: center; gap: 8px; margin: 10px auto;">
            <span style="font-size: 20px;">üìã</span>
            <span>Partager</span>
        </button>
        <button class="modal-button" onclick="restartGame()">Rejouer</button>
    </div>
</div>

<!-- ===== NOTIFICATION ===== -->
<div id="notification" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #28a745; color: white; padding: 15px 30px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 20000; opacity: 0; transition: opacity 0.3s; pointer-events: none;">
    R√©sum√© de la partie copi√© dans le presse-papier
</div>

<!-- ===== MODALE D'AIDE ===== -->
<div class="modal" id="help-modal">
    <div class="modal-content">
        <div class="modal-title help-title">üìñ Comment jouer ?</div>
        <div class="modal-text">
            <p>Fausse Commune est un jeu gratuit qui va tester votre instinct g√©ographique.</p>
            <p>Le jeu g√©n√®re des faux noms de communes fran√ßaises, qui ressemblent √† des noms r√©els de communes aux alentours d'un point donn√©.</p>
            <p>Votre but est de deviner de quel endroit il s'agit en lisant les noms g√©n√©r√©s. Cliquez sur un des points rouges de la carte pour donner votre r√©ponse.</p>
            <p>Attention, au fil des manches ces points sont de plus en plus nombreux et resserr√©s.</p>
            <p>Bonne chance !</p>
        </div>
        <button class="modal-button" onclick="closeHelp()">Compris !</button>
        <p style="margin-top: 20px; font-size: 12px; color: #999; text-align: center;">
            Fausse Commune est un jeu d√©velopp√© par Xavier Geffrier (<a href="https://github.com/XGeffrier" target="_blank" style="color: #457b9d; text-decoration: none;">Github</a>)
        </p>
    </div>
</div>

<script>
    /* ========================================
       VARIABLES GLOBALES
       ======================================== */
    let map; // Objet carte Leaflet
    let currentRound = 0; // Round actuel (commence √† 0)
    let gameSeed; // Seed de la partie actuelle
    let markers = []; // Tableau des marqueurs sur la carte
    let markersById = {};
    let bestScore = 0; // Meilleur score du joueur
    let lives = 2; // Nombre de vies du joueur
    let roundHistory = []; // Historique des rounds (true = gagn√©, false = perdu)
    let gameBlocked = false; // Emp√™che les interactions pendant la r√©v√©lation
    let currentToken = null;
    let pendingToken = null;
    let pendingRoundData = null;
    let waitingForNextRound = false;
    let isRequestInFlight = false;

    const ROUND_ENDPOINT = '/api/round';

    /* ========================================
       GESTION DU MEILLEUR SCORE (LOCALSTORAGE)
       ======================================== */
    /**
     * Charge le meilleur score depuis le localStorage
     * Le localStorage permet de sauvegarder des donn√©es dans le navigateur
     */
    function loadBestScore() {
        const saved = localStorage.getItem('fausseCommune_bestScore');
        if (saved !== null) {
            bestScore = parseInt(saved, 10);
            document.getElementById('best-score-desktop').textContent = bestScore;
        }
        updateMobileScore();
    }

    /**
     * Sauvegarde le meilleur score dans le localStorage
     */
    function saveBestScore(score) {
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('fausseCommune_bestScore', bestScore.toString());
            document.getElementById('best-score-desktop').textContent = bestScore;
            updateMobileScore();
        }
    }

    /**
     * Met √† jour l'affichage du score actuel
     */
    function updateCurrentScore(score) {
        document.getElementById('current-score-desktop').textContent = score;
        updateMobileScore();
    }

    /**
     * Met √† jour l'affichage des vies
     */
    function updateLivesDisplay() {
        document.getElementById('lives-display-desktop').textContent = '‚ù§Ô∏è'.repeat(lives);
        updateMobileScore();
    }

    /**
     * Met √† jour l'affichage mobile (vies + score)
     */
    function updateMobileScore() {
        const currentScore = document.getElementById('current-score-desktop').textContent;
        const bestScoreValue = document.getElementById('best-score-desktop').textContent;
        const livesText = '‚ù§Ô∏è'.repeat(lives);
        const mobileDisplay = document.getElementById('mobile-score-display');
        mobileDisplay.innerHTML = `Vies : ${livesText} <span style="margin-left: 20px;">Score : ${currentScore} (${bestScoreValue})</span>`;
    }

    /* ========================================
       INITIALISATION DE LA CARTE
       ======================================== */
    /**
     * Initialise la carte Leaflet centr√©e sur la France
     */
    function initMap() {
        // Cr√©e la carte dans l'√©l√©ment avec l'id "map"
        // setView([latitude, longitude], niveau_de_zoom)
        map = L.map('map', {maxZoom: 10}).setView([46.603354, 1.888334], 6);
        // Ajoute les tuiles (images de la carte) depuis OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        // Force le recalcul des dimensions imm√©diatement et apr√®s un d√©lai
        // Le premier appel g√®re le cas o√π le CSS est d√©j√† charg√©
        // Le second g√®re le cas o√π le navigateur a besoin de plus de temps
        map.invalidateSize();
        setTimeout(() => map.invalidateSize(), 100);
    }

    /* ========================================
       G√âN√âRATION DE LA SEED
       ======================================== */
    /**
     * G√©n√®re une seed bas√©e sur le timestamp actuel
     * Une nouvelle seed = une nouvelle partie
     */
    function generateSeed() {
        return Math.floor(Date.now() / 1000).toString();
    }

    /* ========================================
       CHARGEMENT D'UN ROUND
       ======================================== */
    /**
     * Charge les donn√©es d'un round depuis l'API Flask
     * @param {string|null} guessId - Identifiant de la r√©ponse pr√©c√©dente (null si nouvelle partie)
     */
    async function requestRound(guessId = null) {
        const payload = {
            token: currentToken,
            guess_id: guessId
        };
        if (!currentToken) {
            payload.game_seed = gameSeed;
        }

        const response = await fetch(ROUND_ENDPOINT, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            throw new Error('Erreur lors du chargement du round');
        }

        const data = await response.json();
        pendingToken = data.token;
        pendingRoundData = data.round;
        await handlePreviousResult(data.previous_result);
        if (!waitingForNextRound) {
            usePendingRound();
        }
    }

    async function handlePreviousResult(result) {
        if (!result) {
            return;
        }

        revealAnswer(result);
        roundHistory.push(result.won);
        const score = roundHistory.filter(r => r).length;
        updateCurrentScore(score);

        if (result.won) {
            await showVictoryOverlay(result.round_ix);
            waitingForNextRound = false;
        } else {
            lives--;
            updateLivesDisplay();
            if (lives > 0) {
                waitingForNextRound = true;
                document.getElementById('remaining-lives').textContent = lives;
                document.getElementById('life-lost-modal').classList.add('show');
            } else {
                waitingForNextRound = true;
                saveBestScore(score);
                document.getElementById('final-round').textContent = score;
                document.getElementById('history-display').textContent = roundHistory.map(r => r ? 'üü¢' : 'üî¥').join('');
                document.getElementById('game-over-modal').classList.add('show');
            }
        }
    }

    /* ========================================
       GESTION DES R√âPONSES
       ======================================== */
    /**
     * R√©v√®le la bonne r√©ponse et ajuste la vue
     */
    function revealAnswer(result) {
        gameBlocked = true;
        Object.entries(markersById).forEach(([id, marker]) => {
            if (id === result.correct_id) {
                marker.setStyle({color: '#28a745', fillColor: '#28a745', fillOpacity: 0.8});
            } else if (!result.won && id === result.guess_id) {
                marker.setStyle({color: '#6c757d', fillColor: '#6c757d', fillOpacity: 0.8});
            }
        });
        const allCoords = Object.values(markersById).map(marker => {
            const latLng = marker.getLatLng();
            return [latLng.lat, latLng.lng];
        });
        if (allCoords.length > 0) {
            map.fitBounds(L.latLngBounds(allCoords), {padding: [50, 50]});
        }
    }

    function showVictoryOverlay(roundIx) {
        return new Promise(resolve => {
            const overlay = document.getElementById('victory-overlay');
            const message = document.getElementById('victory-message');
            message.textContent = `Round ${roundIx + 1} gagn√© ! üéâ`;
            overlay.classList.add('show');
            confetti({
                particleCount: 100,
                spread: 70,
                origin: {y: 0.6},
                zIndex: 100000
            });
            setTimeout(() => {
                overlay.classList.remove('show');
                setTimeout(resolve, 500);
            }, 2000);
        });
    }

    function usePendingRound() {
        if (!pendingRoundData || waitingForNextRound) {
            return;
        }
        currentToken = pendingToken;
        pendingToken = null;
        const nextRound = pendingRoundData;
        pendingRoundData = null;
        displayRound(nextRound);
    }

    /* ========================================
       AFFICHAGE D'UN ROUND
       ======================================== */
    /**
     * Affiche les donn√©es d'un round sur la carte et dans l'interface
     * @param {Object} roundData - Donn√©es du round √† afficher
     */
    function displayRound(roundData) {
        markers.forEach(marker => map.removeLayer(marker));
        markers = [];
        markersById = {};
        gameBlocked = false;

        currentRound = roundData.round_ix;

        const hintsList = document.getElementById('hints-list');
        hintsList.innerHTML = '';
        roundData.fake_names.forEach(hint => {
            const li = document.createElement('li');
            li.className = 'hint-item';
            li.textContent = hint;
            hintsList.appendChild(li);
        });

        roundData.options.forEach(option => {
            const marker = L.circleMarker([option.coords[0], option.coords[1]], {
                color: '#dc3545',
                fillColor: '#dc3545',
                fillOpacity: 0.8,
                radius: 12
            }).addTo(map);
            marker.on('click', () => handleMarkerSelection(option.id));
            markers.push(marker);
            markersById[option.id] = marker;
        });

        const bounds = L.latLngBounds(roundData.options.map(opt => [opt.coords[0], opt.coords[1]]));
        map.fitBounds(bounds, {padding: [50, 50]});
        map.invalidateSize();
    }

    /**
     * Appel√©e quand le joueur clique sur un marqueur (bon ou mauvais)
     */
    async function handleMarkerSelection(optionId) {
        if (gameBlocked || isRequestInFlight) {
            return;
        }
        gameBlocked = true;
        isRequestInFlight = true;
        try {
            await requestRound(optionId);
        } catch (error) {
            console.error('Erreur:', error);
            document.getElementById('hints-list').innerHTML = '<li class="hint-item">Erreur de chargement</li>';
            gameBlocked = false;
        } finally {
            isRequestInFlight = false;
        }
    }

    /* ========================================
       CONTR√îLES DU JEU
       ======================================== */
    /**
     * Continue apr√®s avoir perdu une vie
     */
    function continueAfterLifeLost() {
        document.getElementById('life-lost-modal').classList.remove('show');
        waitingForNextRound = false;
        usePendingRound();
    }

    /**
     * Copie le r√©sum√© de la partie dans le presse-papier
     */
    function shareResult() {
        const score = roundHistory.filter(r => r).length;
        const nbRoundsPlayed = roundHistory.length;
        const historyString = roundHistory.map(r => r ? 'üü¢' : 'üî¥').join('');
        const shareText = `FAUSSE COMMUNE\nJ'ai localis√© correctement ${score} r√©gions sur ${nbRoundsPlayed} !\n${historyString}\n\nJouez sur faussecommune.fr`;

        navigator.clipboard.writeText(shareText).then(() => {
            const notification = document.getElementById('notification');
            notification.style.opacity = '1';
            setTimeout(() => notification.style.opacity = '0', 5000);
        }).catch(err => console.error('Erreur lors de la copie:', err));
    }

    /**
     * Red√©marre une nouvelle partie
     */
    function restartGame() {
        document.getElementById('game-over-modal').classList.remove('show');
        waitingForNextRound = false;
        roundHistory = [];
        lives = 2;
        updateCurrentScore(0);
        updateLivesDisplay();
        currentToken = null;
        pendingToken = null;
        pendingRoundData = null;
        markers.forEach(marker => map.removeLayer(marker));
        markers = [];
        markersById = {};
        gameSeed = generateSeed();
        requestRound().catch(error => {
            console.error('Erreur:', error);
            document.getElementById('hints-list').innerHTML = '<li class="hint-item">Erreur de chargement</li>';
        });
    }

    /**
     * Affiche la modale d'aide
     */
    function showHelp() {
        document.getElementById('help-modal').classList.add('show');
    }

    /**
     * Ferme la modale d'aide
     */
    function closeHelp() {
        document.getElementById('help-modal').classList.remove('show');
    }

    /* ========================================
       INITIALISATION AU CHARGEMENT
       ======================================== */
    /**
     * Fonction ex√©cut√©e quand la page est compl√®tement charg√©e
     */
    window.onload = () => {
        initMap();
        loadBestScore();
        if (bestScore === 0) {
            showHelp();
        }
        gameSeed = generateSeed();
        requestRound().catch(error => {
            console.error('Erreur:', error);
            document.getElementById('hints-list').innerHTML = '<li class="hint-item">Erreur de chargement</li>';
        });
    };

    /**
     * Ajuste la carte quand la fen√™tre change de taille
     */
    window.addEventListener('resize', () => {
        if (map) {
            map.invalidateSize();
        }
    });
</script>
</body>
</html>
